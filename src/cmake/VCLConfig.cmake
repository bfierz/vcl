# Determine the compiler vendor
MESSAGE(STATUS "Detecting compiler: ${CMAKE_CXX_COMPILER_ID}")

IF(${CMAKE_CXX_COMPILER_ID} MATCHES "Intel")
	SET(VCL_COMPILER_INTEL ON)
ELSEIF(${CMAKE_CXX_COMPILER_ID} MATCHES "GNU")
	SET(VCL_COMPILER_GNU ON)
ELSEIF(${CMAKE_CXX_COMPILER_ID} MATCHES "Clang")
	SET(VCL_COMPILER_CLANG ON)
ELSEIF(MSVC)
	SET(VCL_COMPILER_MSVC ON)
ELSE()
	SET(VCL_COMPILER_UNKNOWN ON)
ENDIF()

# Define C++ standard, minimum requirement is C++11
# As MSVC is really able to define the minimum level, software needs
# to implement per feature detection anyway
#SET(VCL_ENABLE_CXX_14 CACHE BOOL "Enable C++ 14")
#SET(VCL_ENABLE_CXX_17 CACHE BOOL "Enable C++ 17")

SET(CMAKE_CXX_STANDARD 14)
SET(CMAKE_CXX_STANDARD_REQUIRED ON)

# Determine platform architexture
IF(CMAKE_SIZEOF_VOID_P EQUAL 8)
	SET(VCL_ADDRESS_SIZE "64")
ELSE()
	SET(VCL_ADDRESS_SIZE "32")
ENDIF()
MESSAGE(STATUS "Compiling for ${VCL_ADDRESS_SIZE}bit machine")

# Determine the underlying OS
MESSAGE(STATUS "Running on ${CMAKE_SYSTEM_NAME} ${CMAKE_SYSTEM_VERSION}")

# Enable Visual Studio solution folders
SET_PROPERTY(GLOBAL PROPERTY USE_FOLDERS ON)

# Control OpenMP support
SET(VCL_OPENMP_SUPPORT CACHE BOOL "Enable OpenMP support")
FIND_PACKAGE(OpenMP)
IF(OPENMP_FOUND AND VCL_OPENMP_SUPPORT)
	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
	SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}")
ENDIF()

# Define vectorisation
SET(VCL_VECTORIZE "SSE 4.1" CACHE STRING "Vectorization instruction set")
SET_PROPERTY(CACHE VCL_VECTORIZE PROPERTY STRINGS "SSE 2" "SSE 3" "SSSE 3" "SSE 4.1" "SSE 4.2" "AVX" "AVX 2" "NEON")

IF (VCL_VECTORIZE STREQUAL "SSE 2")
	SET(VCL_VECTORIZE_SSE2 TRUE)
ELSEIF(VCL_VECTORIZE STREQUAL "SSE 3")
	SET(VCL_VECTORIZE_SSE3 TRUE)
ELSEIF(VCL_VECTORIZE STREQUAL "SSSE 3")
	SET(VCL_VECTORIZE_SSSE3 TRUE)
ELSEIF(VCL_VECTORIZE STREQUAL "SSE 4.1")
	SET(VCL_VECTORIZE_SSE4_1 TRUE)
ELSEIF(VCL_VECTORIZE STREQUAL "SSE 4.2")
	SET(VCL_VECTORIZE_SSE4_2 TRUE)
ELSEIF(VCL_VECTORIZE STREQUAL "AVX")
	SET(VCL_VECTORIZE_AVX TRUE)
ELSEIF(VCL_VECTORIZE STREQUAL "AVX 2")
	SET(VCL_VECTORIZE_AVX2 TRUE)
ELSEIF(VCL_VECTORIZE STREQUAL "NEON")
	SET(VCL_VECTORIZE_NEON TRUE)
ENDIF()
MESSAGE(STATUS "Compiling for ${VCL_VECTORIZE}")

# Set whether contracts should be used
SET(VCL_USE_CONTRACTS CACHE BOOL "Enable contracts")

# Configure MSVC compiler
IF(VCL_COMPILER_MSVC)
	# Configure release configuration
	SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /GS- /fp:fast")
	SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /GS- /fp:fast")
	
	# Configure all configuration
	# * Enable all warnings
	# * Exceptions
	# * RTTI
	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W4 /EHsc /GR")
	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4 /EHsc /GR")
	
	# Make AVX available
	IF(VCL_VECTORIZE_AVX2)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /arch:AVX2")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /arch:AVX2")
	ELSEIF(VCL_VECTORIZE_AVX)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /arch:AVX")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /arch:AVX")
	ELSEIF(VCL_VECTORIZE_SSE2 AND VCL_ADDRESS_SIZE EQUAL "32")
		# All x64 bit machine come with SSE2, thus it's defined as default
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /arch:SSE2")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /arch:SSE2")
	ELSEIF(VCL_VECTORIZE_NEON)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /arch:VFPv4")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /arch:VFPv4")
	ENDIF()

ENDIF(VCL_COMPILER_MSVC)

# Configure GCC and CLANG
IF(VCL_COMPILER_GNU OR VCL_COMPILER_CLANG)

	# Configure all configuration
	# * Enable all warnings
	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")
	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
	IF(VCL_COMPILER_CLANG)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-ignored-attributes")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-ignored-attributes")
	ENDIF() 
	
	IF(VCL_VECTORIZE_AVX2)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mavx2")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mavx2")
	ELSEIF(VCL_VECTORIZE_AVX)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mavx")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mavx")
	ELSEIF(VCL_VECTORIZE_SSE4_2)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -msse4.2")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -msse4.2")
	ELSEIF(VCL_VECTORIZE_SSE4_1)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -msse4.1")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -msse4.1")
	ELSEIF(VCL_VECTORIZE_SSSE3)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -msss3")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mssse3")
	ELSEIF(VCL_VECTORIZE_SSE3)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -msse3")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -msse3")
	ELSEIF(VCL_VECTORIZE_SSE2)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -msse2")
		SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -msse2")
	ENDIF()
ENDIF(VCL_COMPILER_GNU OR VCL_COMPILER_CLANG)

# Function enabling the Core guideline checker from Visual Studio
FUNCTION(enable_vs_guideline_checker target)
    SET_TARGET_PROPERTIES(${target} PROPERTIES
        VS_GLOBAL_EnableCppCoreCheck true
        VS_GLOBAL_CodeAnalysisRuleSet CppCoreCheckRules.ruleset
        VS_GLOBAL_RunCodeAnalysis true)
ENDFUNCTION()

# Support for clang-tidy
FIND_PROGRAM(
	CLANG_TIDY_EXE
	NAMES "clang-tidy"
	DOC "Path to clang-tidy executable"
)
IF(NOT CLANG_TIDY_EXE)
	MESSAGE(STATUS "clang-tidy not found.")
ELSE()
	MESSAGE(STATUS "clang-tidy found: ${CLANG_TIDY_EXE}")
	SET(DO_CLANG_TIDY "${CLANG_TIDY_EXE}" "-checks=*,-clang-analyzer-alpha.*")
ENDIF()

FUNCTION(enable_clang_tidy target)
	IF (${CMAKE_VERSION} VERSION_LESS "3.6.0") 
		MESSAGE(ERROR "Clang-tidy integration requires at least CMake 3.6.0")
	ENDIF()

	IF(CLANG_TIDY_EXE)
		SET_TARGET_PROPERTIES(
			${target} PROPERTIES
			CXX_CLANG_TIDY "${DO_CLANG_TIDY}"
		)
	ENDIF()
ENDFUNCTION()
